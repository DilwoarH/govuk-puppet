#!/usr/bin/env python

"""Query an app's healthcheck endpoint.

Some of our apps are now following this convention for their healthcheck
information:

    {
        "status": "ok",
        "checks": {
            "sufficient_devops": {
                "status": "ok"
            },
            "whizzbangs_recently_frobnicated": {
                "status": "ok"
            }
        }
    }

This script can be invoked with the healthcheck port and path as arguments:

    check_json_healthcheck 3000 /healthcheck

"""

from __future__ import print_function

from contextlib import closing
import json
from socket import timeout
import sys
from urllib2 import urlopen, Request, HTTPError
from urlparse import urlunparse


OK, WARNING, CRITICAL, UNKNOWN = 0, 1, 2, 3

STATUSES = ["ok", "warning", "critical", "unknown"]


def report(exit_code, message, detail_message=None):
    """Report the check's result to STDOUT, then exit."""
    prefix = STATUSES[exit_code].upper()
    print('%s: %s' % (prefix, message))
    if detail_message:
        print("\n" + detail_message)
    exit(exit_code)


def report_error(message):
    """Report an error running this check, then exit."""
    report(UNKNOWN, message)


def handle_exception(exc_type, exception, traceback):
    """Report uncaught exceptions to Nagios as UNKNOWN (exit code 3)."""
    report(UNKNOWN, "unhandled exception: %s" % (exception,))


def url_from_arguments(arguments):
    """Construct a health check URL from command-line arguments.

    The first argument should be the port; the second argument the healthcheck
    path. The healthcheck is assumed to be on localhost and over HTTP.

    """
    check_port = int(arguments[0])
    check_path = arguments[1]

    return urlunparse((
        "http",
        "localhost:%d" % (check_port,),
        check_path,
        None,  # params
        None,  # query
        None   # fragment
    ))


def json_request(request_url):
    """Create a Request object suitable to pass into `urlopen`.
    
    We can't just pass the URL itself into `urlopen`, because we need to add
    an explicit Accept header to be sure the apps we're checking will return a
    suitable response.
    
    """
    return Request(request_url,
                   data=None,
                   headers={"Accept": "application/json"})


if __name__ == "__main__":
    sys.excepthook = handle_exception

    # Any exceptions from this will fall through to the exception hook above
    check_url = url_from_arguments(sys.argv[1:])

    try:
        with closing(urlopen(json_request(check_url), timeout=1)) as response:
            healthcheck_info = json.load(response)
    except HTTPError as e:
        report_error("healthcheck returned HTTP error %d" % (e.code,))
    except timeout:
        report_error("healthcheck timed out")

    try:
        overall_status = healthcheck_info["status"]
    except KeyError:
        report_error("status key missing from healthcheck")

    try:
        status_code = STATUSES.index(overall_status)
    except ValueError:
        report_error("unrecognised overall status: '%s'" % (overall_status,))

    checks = healthcheck_info.get("checks", {})
    check_statuses = [
        (check_name, check_value["status"])
        for (check_name, check_value) in checks.items()
    ]
    if check_statuses:
        check_lines = map(": ".join, check_statuses)  # e.g. "foo_working: ok"
        detail_message = "\n".join(["Checks:"] + check_lines)
    else:
        detail_message = None

    report(status_code, "overall status %s" % (overall_status,), detail_message)
