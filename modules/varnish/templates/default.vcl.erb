# Varnish will append its default logic to any overwritten subroutine. If
# you're not sure what that is, see here:
#
#   https://www.varnish-cache.org/trac/browser/bin/varnishd/default.vcl?rev=2.0

<%-

def vhost_for_backend(name)
  first_part = name.gsub('_', '-')
  "#{first_part}.#{@app_domain}"
end

def set_backend(name)
  # Make sure backend "name" exists
  raise "Backend doesn't exist: '#{name}'!" unless @backends.include? name

  <<-EOM
    set req.http.Host = "#{vhost_for_backend(name)}";
    set req.backend = #{name};
  EOM
end

-%>

# Backends
  backend router {
    .host = "localhost";
    .port = "<%= @router_port -%>";
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 20s;
  }
<% @backends.each do |name| %>
  backend <%= name %> {
    .host = "<%= vhost_for_backend(name) %>";
    .port = "80";
    .first_byte_timeout = 20s;
    .between_bytes_timeout = 20s;
  }
<% end -%>

acl purge_acl {
  "localhost";
  "10.3.0.0"/24;
}

sub vcl_recv {
  # Routing
  if (req.http.GOVUK-Feature-New-Router) {
    set req.backend = router;
  } else if (req.url ~ "^/sitemap[^/]*.xml(\?.*)?$|^/sitemaps/") {
    <%= set_backend('search') %>
  } else if (req.url ~ "^/when-do-the-clocks-change([/?.].*)?$|^/bank-holidays([/?.].*)?$|^/gwyliau-banc([/?.].*)?$") {
    <%= set_backend('calendars') %>
  } else if (req.url ~ "^/(<%= @smartanswers.join("|") %>)([/?.].*)?$") {
    <%= set_backend('smartanswers') %>
  } else if (req.url ~ "^/child-benefit-tax-calculator([/?.].*)?$") {
    <%= set_backend('calculators') %>
  } else if (req.url ~ "^/favicon\.ico(\?.*)?$|^/humans\.txt(\?.*)?$|^/robots\.txt(\?.*)?$|^/fonts|^/google[a-f0-9]{16}\.html(\?.*)?$|^/apple-touch(.*)?\.png$") {
    <%= set_backend('static') %>
  } else if (req.url ~ "^/(designprinciples|service-manual|transformation)([/?.].*)?$") {
    <%= set_backend('designprinciples') %>
  } else if (req.url ~ "^/licence-finder") {
    <%= set_backend('licencefinder') %>
  } else if (req.url ~ "^/business-finance-support-finder") {
    <%= set_backend('businesssupportfinder') %>
  } else if (req.url ~ "^/apply-for-a-licence") {
    <%= set_backend('licensify') %>
  } else if (req.url ~ "^/trade-tariff") {
    <%= set_backend('tariff') %>
  } else if (req.url ~ "^/api") {
    <%= set_backend('publicapi') %>
  } else if (req.url ~ "^/(feedback|contact)([/?.].*)?$") {
    <%= set_backend('feedback') %>
  } else if (req.url ~ "^/performance/([a-z_][a-z0-9_-]+)/api/.+$") {
    <%= set_backend('publicapi') %>
  } else if (req.url ~ "^/performance/?(\?.*)?$|^/performance/dashboard") {
    <%= set_backend('datainsight_frontend') %>
  } else if (req.url ~ "^/performance/transactions-explorer") {
    <%= set_backend('transactions_explorer') %>
  } else if (req.url ~ "^/performance") {
    <%= set_backend('limelight') %>
  } else if (req.url ~ "^/government/") {
    <%= set_backend('whitehall_frontend') %>
  } else if (req.url ~ "^/__canary__$") {
    <%= set_backend('canary_frontend') %>
  <%# This matches on any subpath of the slugs, the bare slugs should fall through to content in Frontend %>
  } else if (req.url ~ "^/pay-foreign-marriage-certificates/(.+)$|^/deposit-foreign-marriage/(.+)$|^/pay-register-death-abroad/(.+)$|^/pay-register-birth-abroad/(.+)$|^/pay-legalisation-post/(.+)$|^/pay-legalisation-drop-off/(.+)$") {
    <%= set_backend('transaction_wrappers') %>
  } else {
    <%= set_backend('frontend') %>
  }

  # https://www.gov.uk/foo/ -> https://www.gov.uk/foo
  # vcl_error completes the redirect
  # Don't redirect "/" to "".
  if (req.url ~ "(.+)/$") {
    set req.http.x-Redir-Url = regsub(req.url, "^(.+)/$", "\1");
    error 667 req.http.x-Redir-Url;
  }

  # normalize Accept-Encoding header
  if (req.http.Accept-Encoding) {
    if (req.url ~ "\.(jpeg|jpg|png|gif|gz|tgz|bz2|tbz|zip|flv|pdf|mp3|ogg)$") {
      remove req.http.Accept-Encoding; # already compressed
    }
    elsif (req.http.Accept-Encoding ~ "gzip") {
      set req.http.Accept-Encoding = "gzip";
    }
    elsif (req.http.Accept-Encoding ~ "deflate") {
      set req.http.Accept-Encoding = "deflate";
    }
    else {
      remove req.http.Accept-Encoding;
    }
  }

  # Don't waste our internal cache on uploaded assets (large) which are
  # typically cached for a long time at the CDN edge.
  if (req.url ~ "^/government/uploads/") {
    return(pass);
  }

  # Serve stale period. This is the period for which Varnish is *allowed* to
  # serve stale content beyond the object TTL in the event of errors from
  # origin.
  set req.grace = 6h;

  # remove cookies
  if (req.backend != licensify) {
    unset req.http.Cookie;
  }

  # purge individual URLs from the cache
  if (req.request == "PURGE") {
    if (!client.ip ~ purge_acl) {
      error 405 "Not allowed";
    } else {
      ban("req.url == " + req.url);
      error 200 "Purged";
    }
  }

  # Usually, varnish would refuse to cache requests with an Authorization
  # header. We don't mind, so return lookup.
  if (req.request == "GET" || req.request == "HEAD") {
    if (req.http.Authorization) {
      return(lookup);
    }
  }
}

sub vcl_fetch {
  # Serve stale period. This is the period for which Varnish is allowed to
  # keep an object, beyond its specified TTL. It should always be as long or
  # longer than req.grace in vcl_recv.
  set beresp.grace = 6h;

  if (req.backend == licensify) {
    # Licensify sends custom 500 errors, and we need to send No-Fallback: true
    # to prevent the CDN from falling back to the mirror site.
    # Unfortunately, with our current build of Nginx we can't use add_headers
    # for an error response, so this will have to live here.
    #
    # FIXME: This should be implemented by either the app or the per-app Nginx
    # (by compiling Nginx with the more_headers module, for example).
    #
    # - NS 2012-12-11
    set beresp.http.No-Fallback = "true";

  # Remove cookies for all apps but Licensify
  } else {
    unset beresp.http.set-cookie;
  }

  # Don't cache 5xx errors from backends. Keep retrying and let them present
  # their own errors pages if necessary.
  if (beresp.status >= 500 && beresp.status <= 504) {
    # Don't cache the decision to not cache
    set beresp.ttl = 0s;
    return(hit_for_pass);
  }

  # hide some internal headers
  unset beresp.http.X-Rack-Cache;
  unset beresp.http.X-Runtime;

  # If the backend says no-cache or no-store, we should not cache
  if (beresp.http.cache-control ~ "no-cache" || beresp.http.cache-control ~ "no-store") {
    # Don't cache the decision to not cache
    set beresp.ttl = 0s;
    return(hit_for_pass);
  }

  # If neither a Cache-Control or Expires header is provided, Varnish will
  # automatically set the TTL to the default_ttl. This *won't* however, set
  # this for downstreams. Explicitly set a C-C header if we intercept a
  # response with no useable caching information.
  if (!beresp.http.Cache-Control && !beresp.http.Expires) {
    set beresp.http.X-Varnish-Defaulted = "1";
    set beresp.http.Cache-Control = "max-age=<%= scope.lookupvar('varnish::default_ttl') %>";
  }

  # if we get a 503 error then server stale content
  if (beresp.status >= 503 && beresp.status <= 504) {
    set beresp.saintmode = 30s;
    if (req.restarts > 0) {
      return(restart);
    }
  }

  # Allow cached authorized requests
  if (req.http.Authorization) {
    return(deliver);
  }

  # Ignore cookies for caching purposes
  if (beresp.http.Set-Cookie) {
    return(deliver);
  }
}

sub vcl_hash {
  hash_data(req.url);
  return(hash);
}

sub vcl_deliver {
  # Add a custom header to indicate whether we hit the cache or not
  if (obj.hits > 0) {
    set resp.http.X-Cache = "HIT";
  } else {
    set resp.http.X-Cache = "MISS";
  }
}

sub vcl_error {
  # 667 errors are our internal "redirect wanted" errors
  # They're raised in vcl_recv.
  if (obj.status == 667) {
    set obj.http.Location = obj.response;
    set obj.status = 301;
    return(deliver);
  }
}
